var h=Object.defineProperty;var w=(t,r,e)=>r in t?h(t,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[r]=e;var c=(t,r,e)=>w(t,typeof r!="symbol"?r+"":r,e);import{ab as f}from"./app-CLj7mONa.js";/*! 2FAuth version 6.0.0 - Copyright (c) 2025 Bubka - https://github.com/Bubka/2FAuth */class y{constructor(){c(this,"controller")}createNewAbortSignal(){if(this.controller){const e=new Error("Cancelling existing WebAuthn API call for new one");e.name="AbortError",this.controller.abort(e)}const r=new AbortController;return this.controller=r,r.signal}}const d=new y;function g(t){return t==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(t)}function _(t,r){var n,o;const{publicKey:e}=r;if(t.name==="AbortError"){if(r.signal instanceof AbortSignal)return{phrase:"error.aborted_by_user",type:"is-warning"}}else if(t.name==="ConstraintError"){if(((n=e.authenticatorSelection)==null?void 0:n.requireResidentKey)===!0)return{phrase:"error.authenticator_missing_discoverable_credential_support",type:"is-danger"};if(((o=e.authenticatorSelection)==null?void 0:o.userVerification)==="required")return{phrase:"error.authenticator_missing_user_verification_support",type:"is-danger"}}else{if(t.name==="InvalidStateError")return{phrase:"error.security_device_already_registered",type:"is-danger"};if(t.name==="NotAllowedError")return{phrase:"error.not_allowed_operation",type:"is-danger"};if(t.name==="NotSupportedError")return e.pubKeyCredParams.filter(u=>u.type==="public-key").length===0?{phrase:"error.no_entry_was_of_type_public_key",type:"is-danger"}:{phrase:"error.no_authenticator_support_specified_algorithms",type:"is-danger"};if(t.name==="SecurityError"){const i=window.location.hostname;if(g(i)){if(e.rp.id!==i)return{phrase:"error.security_error_check_rpid",type:"is-danger"}}else return{phrase:"error.2fauth_has_not_a_valid_domain",type:"is-danger"}}else if(t.name==="TypeError"){if(e.user.id.byteLength<1||e.user.id.byteLength>64)return{phrase:"error.user_id_not_between_1_64",type:"is-danger"}}else if(t.name==="UnknownError")return{phrase:"error.unknown_error",type:"is-danger"}}return{phrase:"error.unknown_error",type:"is-danger"}}function m(t,r){const{publicKey:e}=r;if(t.name==="AbortError"){if(r.signal instanceof AbortSignal)return{phrase:"error.aborted_by_user",type:"is-warning"}}else{if(t.name==="NotAllowedError")return{phrase:"error.not_allowed_operation",type:"is-danger"};if(t.name==="SecurityError"){const n=window.location.hostname;if(g(n)){if(e.rpId!==n)return{phrase:"error.security_error_check_rpid",type:"is-danger"}}else return{phrase:"error.2fauth_has_not_a_valid_domain",type:"is-danger"}}else if(t.name==="UnknownError")return{phrase:"error.unknown_error",type:"is-danger"}}return{phrase:"error.unknown_error",type:"is-danger"}}const p=f("web");class a{async register(){let r={webauthn:!0,type:"is-danger",message:""};if(!window.isSecureContext)return r.message="error.https_required",Promise.reject(r);if(!a.supportsWebAuthn)return r.message="error.browser_does_not_support_webauthn",Promise.reject(r);const e=await p.post("/webauthn/register/options").then(s=>s.data);let o={publicKey:a.parseIncomingServerOptions(e)};o.signal=d.createNewAbortSignal();let i;try{i=await navigator.credentials.create(o)}catch(s){const l=_(s,o);return Promise.reject({webauthn:!0,type:l.type,message:l.phrase})}const u=a.parseOutgoingCredentials(i);return p.post("/webauthn/register",u,{returnError:!0})}async authenticate(r){if(!window.isSecureContext)return err.message="error.https_required",Promise.reject(err);if(!a.supportsWebAuthn)return err.message="error.browser_does_not_support_webauthn",Promise.reject(err);const e=await p.post("/webauthn/login/options",{email:r}).then(s=>s.data);let o={publicKey:a.parseIncomingServerOptions(e)};o.signal=d.createNewAbortSignal();const i=await navigator.credentials.get(o).catch(s=>{const l=m(s,o);return Promise.reject({webauthn:!0,type:l.type,message:l.phrase})});let u=a.parseOutgoingCredentials(i);return u.email=r,p.post("/webauthn/login",u,{returnError:!0})}static parseIncomingServerOptions(r){return r.challenge=a.uint8Array(r.challenge),"user"in r&&(r.user={...r.user,id:a.uint8Array(r.user.id)}),["excludeCredentials","allowCredentials"].filter(e=>e in r).forEach(e=>{r[e]=r[e].map(n=>({...n,id:a.uint8Array(n.id)}))}),r}static parseOutgoingCredentials(r){let e={id:r.id,type:r.type,rawId:a.arrayToBase64String(r.rawId),response:{}};return["clientDataJSON","attestationObject","authenticatorData","signature","userHandle"].filter(n=>n in r.response).forEach(n=>e.response[n]=a.arrayToBase64String(r.response[n])),e}static uint8Array(r,e=!1){return Uint8Array.from(e?atob(r):a.base64UrlDecode(r),n=>n.charCodeAt(0))}static arrayToBase64String(r){return btoa(String.fromCharCode(...new Uint8Array(r)))}static base64UrlDecode(r){r=r.replace(/-/g,"+").replace(/_/g,"/");const e=r.length%4;if(e){if(e===1)throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");r+=new Array(5-e).join("=")}return atob(r)}static supportsWebAuthn(){return(window==null?void 0:window.PublicKeyCredential)!==void 0&&typeof window.PublicKeyCredential=="function"}}const C=new a;export{C as w};
